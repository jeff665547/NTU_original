tickfont = list(family = 'Arial',
size = 20,
color = 'rgb(82, 82, 82)'),
showarrow = TRUE,
domain = c(0, 0.6))
yaxis = list(title = "<b>Power</b>",
titlefont = list(family = 'MS Reference Sans Serif',
size = 28),
tickmode = "linear",
tick0 = 0,
dtick = 0.2,
tickfont = list(family = 'Arial',
size = 20,
color = 'rgb(82, 82, 82)'),
showgrid = TRUE,
gridcolor = 'rgb(174, 174, 174)',
gridwidth = 1.4,
zeroline = FALSE,
showline = FALSE,
showticklabels = TRUE)
margin = list(autoexpand = TRUE,
l = 130,
r = 200,
t = 80,
b = 70)
p = plot_ly(data)  %>%
add_trace(x = ~X, y = ~countG_Perm, name = "<b>Global Test</b>", mode = 'lines+markers', line = list(color = border.colors[1], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[1]), fill = "tozeroy", fillcolor = fill.colors[1]) %>%
add_trace(x = ~X, y = ~countGlobalAncova, name = "<b>GlobalANCOVA</b>", mode = 'lines+markers', line = list(color = border.colors[2], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[2]), fill = "tozeroy", fillcolor = fill.colors[2]) %>%
add_trace(x = ~X, y = ~countN_Perm, name = "<b>Energy Test(N-statistic)</b>", mode = 'lines+markers', line = list(color = border.colors[3], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[3]), fill = "tozeroy", fillcolor = fill.colors[3]) %>%
add_trace(x = ~X, y = ~countGSEA_Category, name = "<b>GSEA(Category)</b>", mode = 'lines+markers', line = list(color = border.colors[4], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[4]), fill = "tozeroy", fillcolor = fill.colors[4]) %>%
add_trace(x = ~X, y = ~countH_Pseudo_Perm, name = "<b>Hotelling's T<sup>2</sup></b>", mode = 'lines+markers', line = list(color = border.colors[5], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[5]), fill = "tozeroy", fillcolor = fill.colors[5])
p = add_trace(p, x = c(0, 2), y = 0.8, name = "<b>Power: 0.8</b>", mode = 'lines', line = list(color = rgb(50/255, 158/255, 83/255, 0.7), shape = "spline")) %>%
add_trace(x = c(0, 2), y = 0.5, name = "<b>Power: 0.5</b>", mode = 'lines', line = list(color = rgb(212/255, 54/255, 55/255, 0.5), shape = "spline")) %>%
add_trace(x = c(0, 2), y = 0.05, name = "<b>Type I error rate: 0.05</b>", mode = 'lines', line = list(color = rgb(212/255, 54/255, 55/255, 0.5), shape = "spline", dash = "dash"))
final = layout(p, font = list(family = "serif",
size = 15),
xaxis = xaxis,
yaxis = yaxis,
margin = margin,
autosize = TRUE,
showlegend = TRUE,
legend = list(x = 0.8, y = 0.93,
bgcolor = "transparent",
font = list(family = "MS Reference Sans Serif")),
plot_bgcolor = "rgba(200, 200, 200, 0.3)")
return(final)
}
power_curve(data = dataI)
power_curve(data = dataII)
power_curve(data = dataIII)
power_curve(data = dataIV)
power_curve(data = dataV)
power_curve(data = dataVI)
#Plot Program
power_curve = function(data = data, smoothpar = 0.8){
fill.colors = c("rgba(0, 207, 213, 0.15)",
"rgba(255, 153, 201, 0.15)", "rgba(27, 44, 193, 0.15)",
"rgba(87, 184, 255, 0.15)", "rgba(249, 133, 32, 0.15)")
#radar plot 每個individual要畫邊界所使用的色彩
border.colors = c("rgba(0, 207, 213, 1)",
"rgba(255, 153, 201, 1)", "rgba(27, 44, 193, 1)",
"rgba(87, 184, 255, 1)", "rgba(249, 133, 32, 1)")
#radar plot 每個individual要畫邊界(點)所使用的符號(symbols)
dot.symbols = c("circle", "square", "diamond", "triangle-up", "star")
#radar plot 每個individual要畫邊界(點)所使用的大小
dot.size = 13
xaxis = list(title = "<b>Δ</b>",
titlefont = list(family = 'MS Reference Sans Serif',
size = 28),
showline = FALSE,
showgrid = TRUE,
gridcolor = 'rgb(174, 174, 174)',
gridwidth = 1.4,
zeroline = FALSE,
showticklabels = TRUE,
linecolor = 'rgba(100, 100, 100, 0.3)',
linewidth = 1,
autotick = TRUE,
type = "linear",
range = list(0, 1.15),
tickmode = "linear",
tick0 = 0.1,
dtick = 0.2,
tickfont = list(family = 'Arial',
size = 20,
color = 'rgb(82, 82, 82)'),
showarrow = TRUE,
domain = c(0, 0.6))
yaxis = list(title = "<b>Power</b>",
titlefont = list(family = 'MS Reference Sans Serif',
size = 28),
tickmode = "linear",
tick0 = 0,
dtick = 0.2,
tickfont = list(family = 'Arial',
size = 20,
color = 'rgb(82, 82, 82)'),
showgrid = TRUE,
gridcolor = 'rgb(174, 174, 174)',
gridwidth = 1.4,
zeroline = FALSE,
showline = FALSE,
showticklabels = TRUE)
margin = list(autoexpand = TRUE,
l = 130,
r = 200,
t = 80,
b = 70)
p = plot_ly(data)  %>%
add_trace(x = ~X, y = ~countG_Perm, name = "<b>Global Test</b>", mode = 'lines+markers', line = list(color = border.colors[1], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[1]), fill = "tozeroy", fillcolor = fill.colors[1]) %>%
add_trace(x = ~X, y = ~countGlobalAncova, name = "<b>GlobalANCOVA</b>", mode = 'lines+markers', line = list(color = border.colors[2], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[2]), fill = "tozeroy", fillcolor = fill.colors[2]) %>%
add_trace(x = ~X, y = ~countN_Perm, name = "<b>Energy Test(N-statistic)</b>", mode = 'lines+markers', line = list(color = border.colors[3], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[3]), fill = "tozeroy", fillcolor = fill.colors[3]) %>%
add_trace(x = ~X, y = ~countGSEA_Category, name = "<b>GSEA(Category)</b>", mode = 'lines+markers', line = list(color = border.colors[4], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[4]), fill = "tozeroy", fillcolor = fill.colors[4]) %>%
add_trace(x = ~X, y = ~countH_Pseudo_Perm, name = "<b>Hotelling's T<sup>2</sup></b>", mode = 'lines+markers', line = list(color = border.colors[5], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[5]), fill = "tozeroy", fillcolor = fill.colors[5])
p = add_trace(p, x = c(0, 2), y = 0.8, name = "<b>Power: 0.8</b>", mode = 'lines', line = list(color = rgb(50/255, 158/255, 83/255, 0.7), shape = "spline")) %>%
add_trace(x = c(0, 2), y = 0.5, name = "<b>Power: 0.5</b>", mode = 'lines', line = list(color = rgb(212/255, 54/255, 55/255, 0.5), shape = "spline")) %>%
add_trace(x = c(0, 2), y = 0.05, name = "<b>Type I error rate: 0.05</b>", mode = 'lines', line = list(color = rgb(212/255, 54/255, 55/255, 0.5), shape = "spline", dash = "dash"))
final = layout(p, font = list(family = "serif",
size = 15),
xaxis = xaxis,
yaxis = yaxis,
margin = margin,
autosize = TRUE,
showlegend = TRUE,
legend = list(x = 0.8, y = 0.93,
bgcolor = "transparent",
font = list(family = "MS Reference Sans Serif")),
plot_bgcolor = "rgba(200, 200, 200, 0.3)")
return(final)
}
power_curve(data = dataII)
power_curve(data = dataIII)
power_curve(data = dataIV)
power_curve(data = dataV)
power_curve(data = dataVI)
power_curve(data = dataI)
#Hotelling's T^2
#install.packages("Hotelling")
#shrinkage: Shaefer and Strimmer’s James-Stein shrinkage estimator (An efficient way to compute the correlation matrix, even when n < p is also suitable.)
#progBar: progress bar
#Usage: row: sample, column: variable, x: data1, y: data2
library(Hotelling)
#The global test
#source("https://bioconductor.org/biocLite.R")
#biocLite("globaltest")
#biocLite("golubEsets")
library(globaltest)
#The N-statistic(Energy Test)
source("https://jeff665547.github.io/Study/Cramer%20test.R")
#Multivariate Kolmogorov-Smirnov test
#biocLite("GSAR")
library(GSAR)
#GSEA-Category package(GSEA like methods)
#source("https://bioconductor.org/biocLite.R")
#biocLite("Category")
#biocLite("Biobase")
library(Category)
library(Biobase)
#GSEA(Subramanian et al 2005)
source("https://jeff665547.github.io/Study/GSEA.1.0.R")
#globalANCOVA
#source("https://bioconductor.org/biocLite.R")
#biocLite("GlobalAncova")
library(GlobalAncova)
#SAFE
#biocLite("safe")
library(safe)
#########################################################################################
#Power analysis
library(Hotelling)
library(globaltest)
library(Category)
library(GlobalAncova)
library(MVN)
library(mvtnorm)
library(energy)
#Random sample from multivariate normal distribution(MVN) with customized parameters settings
mvnormal = function(n, probenumber, rho, MEAN = rep(0, probenumber), rhostructure = "CS"){
#n: Sample size. (樣本數)
#probenumber: The number of dimensions(genes). (維度，基因數目)
#rho: Correlation between any two dimensions(genes). (任意兩個維度，基因之間的相關係數)
#rhostructure: Structure of correlation matrix. (關係係數矩陣的結構樣式), e.g.:"CS": Compound Symmertry, "UN": Unstructured
#Program start:
#Create correlation matrix
if(rhostructure == "CS"){
SIGMA = matrix(rho, probenumber, probenumber)
diag(SIGMA) = 1
}else if(rhostructure == "UN"){
rhovector = c(0.1, 0.3, 0.5, 0.7, 0.9)
SIGMA = matrix(c(sample(rhovector, size = probenumber*probenumber, replace = TRUE)),
probenumber, probenumber)
diag(SIGMA) = 1
}
#Generate observation from MVN from package "mvtnorm".
obs = rmvnorm(n, mean = MEAN, sigma = SIGMA)
return(obs)
}
#Random sample from multivariate t distribution(MVT) with customized parameters settings
mvt = function(n, probenumber, rho, rhostructure = "CS", DF){
#n: Sample size. (樣本數)
#probenumber: The number of dimensions(genes). (維度，基因數目)
#rho: Correlation between any two dimensions(genes). (任意兩個維度，基因之間的相關係數)
#rhostructure: Structure of correlation matrix. (關係係數矩陣的結構樣式), e.g.:"CS": Compound Symmertry, "UN": Unstructured
#DF: Degrees of freedom of multivariate t distribution, DF > 2. (多為t分配的自由度,DF 需要大於 2)
#Program start:
#Create correlation matrtix
if(rhostructure == "CS"){
rhomatrix = matrix(rho, probenumber, probenumber)
diag(rhomatrix) = 1
}else if(rhostructure == "UN"){
rhovector = c(0.1, 0.3, 0.5, 0.7, 0.9)
rhomatrix = matrix(c(sample(rhovector, size = probenumber*probenumber, replace = TRUE)),
probenumber, probenumber)
diag(rhomatrix) = 1
}
#Transform correlation matrix into scale matrix. (將相關係數矩陣轉換成多維度t分配中的scale matrix)
if(DF > 2){
SIGMA <<- rhomatrix*((DF - 2)/DF)
}else{
cat("error: df must > 2 \n")
}
#Generate observation from MVT from package "mvtnorm".
obs = rmvt(n, sigma = SIGMA, df = DF)
return(obs)
}
#Use the concept of probability integral transformation(PIT) to
#create various scenarios: Mixture of MVN, MVT(df=3),
#                          MVN(high correlation: 0.9, low correlation: 0.1)
generateobs = function(n, probenumber, alternative = c("normal", "normal"), alternumber = 2,
proportion = rep(1/alternumber, alternumber), MEAN = list(rep(0, probenumber),rep(0, probenumber)),
rho, rhostructure = rep("CS", alternumber), DF = Inf){
#n: Sample size of the (mixture) distribution.
#   (從(混合)分配生出來的樣本數)
#probenumber: The number of dimensions(genes) for the (mixture) distribution.
#             ((混合)分配的維度(變數、基因)數目)
#alternative: The distribution types vector used for creating the (mixture) distribution.
#             (創造(混合)分配所需的分配類型)
#alternumber: The number of components in the mixture distribution.
#             (混合分配所要用到的分配個數)
#proportion: The proportion for each distribution used for creating mixture distribution.
#            (各個分配在混合分配中所要的混合比例)
#MEAN: The mean vectors for all distributions used for creating mixture distribution.
#      (混合分配中每個分配的期望值向量)
#rho: Correlation between any two dimensions(genes) for all distributions used for creating mixture distribution.
#     (混合分配中每個分配裡任意兩個維度(變數、基因)之間的相關係數)
#rhostructure: Structure of correlation matrix for all distributions used for creating mixture distribution.
#              (混合分配中的每個分配所需要用到的關係係數矩陣的結構樣式),
#              e.g.:"CS": Compound Symmertry, "UN": Unstructured
#DF: Degrees of freedom of multivariate t distribution(if it is needed).
#    (多維t分配的自由度(如果需要用到的話), DF 需要大於 2)
#    DF > 2
#Program start:
#seed: All data seed
#obs: All generated observation.
#j: The value of indicator function: 1 = Distribution 1 of "alternative" vector,
#                                    2 = Distribution 2 of "alternative" vector.
#p: The cumulative probability of the proportion for each distribution in the mixture distribution.
#per: Each generated observation.
seed = runif(n)
obs = c()
for(i in seed){
j = 1
p = proportion[1]
while(TRUE){
if(j > alternumber){
break
}else if(i <= p){
if(alternative[j] == "normal"){
per = mvnormal(n = 1, probenumber = probenumber, MEAN = MEAN[[j]],
rho = rho[j], rhostructure = rhostructure[j])
}else if(alternative[j] == "t"){
per = mvt(n = 1, probenumber = probenumber, rho = rho[j], DF = DF,
rhostructure = rhostructure[j])
}else{
per = NA
}
obs = rbind(obs, per)
break
}else{
j = j + 1
p = p + proportion[j]
}
}
}
return(obs)
}
##########################################################################################
#Mixture of Normal with same mean setting using fixed Mean Difference
simulationresult = c()
rholist = list()
rholist[[1]] = c(0.1)
############################################################################################################################################
#Multivariate Normal Power Simulation(rho=0.1 and 0.9))
simulationresult = c()
rholist = list()
rholist[[1]] = c(0.1)
proportionlist = list()
proportionlist[[1]] = c(1)
times = 1000
for(prop in proportionlist){
print(prop)
for(rho in rholist){
print(paste0("rho = ", rho))
for(probenumber in 30){
print(paste0("probenumber = ", probenumber))
for(m in c(70)){
print(paste0("sample = ", m))
for (difference in c(0.2, 0.4)){
print(difference)
#GSA Tools start
names = c("countH_Pseudo_Perm", "countG", "countG_Perm", "countGlobalAncova", "countN_Perm", "countGSEA_Category")
for(i in 1: length(names)) assign(names[i], 0)
for(s in 1: times){
print(s)
set.seed(s)
obs1 = generateobs(n = m/2, probenumber = probenumber, alternative = "normal",
alternumber = 1,
MEAN = list(rep(0, probenumber)),
proportion = prop, rho = rho)
set.seed(s + 2*times)
obs2 = generateobs(n = m/2, probenumber = probenumber, alternative = "normal",
alternumber = 1,
MEAN = list(rep(0 + difference, probenumber)),
proportion = prop, rho = rho)
obs = rbind(obs1, obs2)
colnames(obs) = paste0("V",(1:ncol(obs)))
rownames(obs) = paste0("N",(1:nrow(obs)))
sig = 0.05
print("Hotelling")
#resultH_Pseudo = hotelling.test(obs1, obs2, shrinkage = TRUE, perm = FALSE, B = 1000, progBar =  FALSE)
resultH_Pseudo_Perm = hotelling.test(obs1, obs2, shrinkage = TRUE, perm = TRUE, B = 1000, progBar =  FALSE)
#resultH = hotelling.test(obs1, obs2, shrinkage = FALSE, perm = FALSE, B = 1000, progBar =  FALSE)
#resultH_Perm = hotelling.test(obs1, obs2, shrinkage = FALSE, perm = TRUE, B = 1000, progBar =  FALSE)
print("Global")
resultG = gt(rep(c(TRUE, FALSE), c(nrow(obs1),nrow(obs2))), obs)
resultG_Perm = gt(rep(c(TRUE, FALSE), c(nrow(obs1),nrow(obs2))), obs ,permutations = 1000)
print("GlobalAncova")
resultGlobalAncova = GlobalAncova(xx = t(obs), group = rep(c(0, 1), c(m/2, m/2)),
covars=NULL, perm=1000)
print("N-statistic")
resultN_Perm = eqdist.etest(obs, sizes=c(m/2, m/2) , R = 1000)
print("GSEA(Category)")
gseadata = ExpressionSet(t(obs))
response = as.factor(rep(c("A", "B"), c(m/2, m/2)))
signset = matrix(1, nrow = 1, ncol = probenumber)
colnames(signset) = rownames(gseadata)
rownames(signset) = "geneset"
resultGSEA_Category = gseattperm(gseadata, response, signset, 1000)
if(resultH_Pseudo_Perm$pval < sig){
countH_Pseudo_Perm = countH_Pseudo_Perm + 1
}
if(resultG@result[1] < sig){
countG = countG + 1
}
if(resultG_Perm@result[1] < sig){
countG_Perm = countG_Perm + 1
}
if(resultGlobalAncova$test.result[2,] < sig){
countGlobalAncova = countGlobalAncova + 1
}
if(resultN_Perm$p.value < sig){
countN_Perm = countN_Perm + 1
}
if((resultGSEA_Category[1] < sig/2) || (resultGSEA_Category[2] < sig/2)){
countGSEA_Category = countGSEA_Category + 1
}
}
count <<- matrix(c(countH_Pseudo_Perm,  countG, countG_Perm, countGlobalAncova, countN_Perm, countGSEA_Category), 1, length(names))
#GSA Tools end
colnames(count) = names
rownames(count) = paste0("composition:", paste0(as.character(prop), collapse = "", sep = " "),
",rho:", paste0(as.character(rho), collapse = "", sep = " "),
",probes:", probenumber,
",size:", m,
",difference:", difference)
simulationresult <<- rbind(simulationresult, (count/times))
}
}
}
}
}
#Plot Program
power_curve = function(data = data, smoothpar = 1){
fill.colors = c("rgba(0, 207, 213, 0.15)",
"rgba(255, 153, 201, 0.15)", "rgba(27, 44, 193, 0.15)",
"rgba(87, 184, 255, 0.15)", "rgba(249, 133, 32, 0.15)")
#radar plot 每個individual要畫邊界所使用的色彩
border.colors = c("rgba(0, 207, 213, 1)",
"rgba(255, 153, 201, 1)", "rgba(27, 44, 193, 1)",
"rgba(87, 184, 255, 1)", "rgba(249, 133, 32, 1)")
#radar plot 每個individual要畫邊界(點)所使用的符號(symbols)
dot.symbols = c("circle", "square", "diamond", "triangle-up", "star")
#radar plot 每個individual要畫邊界(點)所使用的大小
dot.size = 13
xaxis = list(title = "<b>Δ</b>",
titlefont = list(family = 'MS Reference Sans Serif',
size = 28),
showline = FALSE,
showgrid = TRUE,
gridcolor = 'rgb(174, 174, 174)',
gridwidth = 1.4,
zeroline = FALSE,
showticklabels = TRUE,
linecolor = 'rgba(100, 100, 100, 0.3)',
linewidth = 1,
autotick = TRUE,
type = "linear",
range = list(0, 1.15),
tickmode = "linear",
tick0 = 0.1,
dtick = 0.2,
tickfont = list(family = 'Arial',
size = 20,
color = 'rgb(82, 82, 82)'),
showarrow = TRUE,
domain = c(0, 0.6))
yaxis = list(title = "<b>Power</b>",
titlefont = list(family = 'MS Reference Sans Serif',
size = 28),
tickmode = "linear",
tick0 = 0,
dtick = 0.2,
tickfont = list(family = 'Arial',
size = 20,
color = 'rgb(82, 82, 82)'),
showgrid = TRUE,
gridcolor = 'rgb(174, 174, 174)',
gridwidth = 1.4,
zeroline = FALSE,
showline = FALSE,
showticklabels = TRUE)
margin = list(autoexpand = TRUE,
l = 130,
r = 200,
t = 80,
b = 70)
p = plot_ly(data)  %>%
add_trace(x = ~X, y = ~countG_Perm, name = "<b>Global Test</b>", mode = 'lines+markers', line = list(color = border.colors[1], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[1]), fill = "tozeroy", fillcolor = fill.colors[1]) %>%
add_trace(x = ~X, y = ~countGlobalAncova, name = "<b>GlobalANCOVA</b>", mode = 'lines+markers', line = list(color = border.colors[2], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[2]), fill = "tozeroy", fillcolor = fill.colors[2]) %>%
add_trace(x = ~X, y = ~countN_Perm, name = "<b>Energy Test(N-statistic)</b>", mode = 'lines+markers', line = list(color = border.colors[3], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[3]), fill = "tozeroy", fillcolor = fill.colors[3]) %>%
add_trace(x = ~X, y = ~countGSEA_Category, name = "<b>GSEA(Category)</b>", mode = 'lines+markers', line = list(color = border.colors[4], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[4]), fill = "tozeroy", fillcolor = fill.colors[4]) %>%
add_trace(x = ~X, y = ~countH_Pseudo_Perm, name = "<b>Hotelling's T<sup>2</sup></b>", mode = 'lines+markers', line = list(color = border.colors[5], shape = "spline", smoothing = smoothpar), marker = list(color = border.colors[5]), fill = "tozeroy", fillcolor = fill.colors[5])
p = add_trace(p, x = c(0, 2), y = 0.8, name = "<b>Power: 0.8</b>", mode = 'lines', line = list(color = rgb(50/255, 158/255, 83/255, 0.7), shape = "spline")) %>%
add_trace(x = c(0, 2), y = 0.5, name = "<b>Power: 0.5</b>", mode = 'lines', line = list(color = rgb(212/255, 54/255, 55/255, 0.5), shape = "spline")) %>%
add_trace(x = c(0, 2), y = 0.05, name = "<b>Type I error rate: 0.05</b>", mode = 'lines', line = list(color = rgb(212/255, 54/255, 55/255, 0.5), shape = "spline", dash = "dash"))
final = layout(p, font = list(family = "serif",
size = 15),
xaxis = xaxis,
yaxis = yaxis,
margin = margin,
autosize = TRUE,
showlegend = TRUE,
legend = list(x = 0.8, y = 0.93,
bgcolor = "transparent",
font = list(family = "MS Reference Sans Serif")),
plot_bgcolor = "rgba(200, 200, 200, 0.3)")
return(final)
}
simulationresult
AA = simulationresult
resultI[1:3,]
rbind(resultI[1:3,], AA[1,], resultI[4,])
rbind(resultI[1:3,], AA[1,])
AA[1,]
AA
resultI
AA
rbind(resultI[1:3,-1], AA[1,])
resultI
rbind(resultI[1:3,-1], AA[1,], resultI[4,-1], AA[2,], resultI[5:9,-1])
AA
AA[1,]
AA[2,]
matrix(c(0.4, 0.517, 0.518, 0.5, 0.5, 0.620, 0.95, 0.986,
0.987, 0.984, 0.982, 0.994), nrow = 2, ncol = 6, byrow = TRUE)
AA = matrix(c(0.4, 0.517, 0.518, 0.5, 0.5, 0.620, 0.95, 0.986,
0.987, 0.984, 0.982, 0.994), nrow = 2, ncol = 6, byrow = TRUE)
#Scenario I (MVN rho:0.1)
resultI = read.csv("GSA tools power simulation(multivariate normal distribution(rho=0.1 and 0.9)).csv")[1:9,]
resultI[,1] = c(0, 0.05, 0.1, 0.3, 0.5,  0.7, 0.9, 1, 2)
AA = matrix(c(0.4, 0.517, 0.518, 0.5, 0.5, 0.620, 0.95, 0.986,
0.987, 0.984, 0.982, 0.994), nrow = 2, ncol = 6, byrow = TRUE)
resultI = rbind(resultI[1:3,-1], AA[1,], resultI[4,-1], AA[2,], resultI[5:9,-1])
resultI
resultI[4,-1]
resultI
#Scenario I (MVN rho:0.1)
resultI = read.csv("GSA tools power simulation(multivariate normal distribution(rho=0.1 and 0.9)).csv")[1:9,]
resultI
resultI[,1] = c(0, 0.05, 0.1, 0.3, 0.5,  0.7, 0.9, 1, 2)
AA = matrix(c(0.4, 0.517, 0.518, 0.5, 0.5, 0.620, 0.95, 0.986,
0.987, 0.984, 0.982, 0.994), nrow = 2, ncol = 6, byrow = TRUE)
resultI
resultI[,1] = c(0, 0.05, 0.1, 0.3, 0.5,  0.7, 0.9, 1, 2)
#Scenario I (MVN rho:0.1)
resultI = read.csv("GSA tools power simulation(multivariate normal distribution(rho=0.1 and 0.9)).csv")[1:9,]
resultI[,1] = c(0, 0.05, 0.1, 0.3, 0.5,  0.7, 0.9, 1, 2)
AA = matrix(c(0.4, 0.517, 0.518, 0.5, 0.5, 0.620, 0.95, 0.986,
0.987, 0.984, 0.982, 0.994), nrow = 2, ncol = 6, byrow = TRUE)
NresultI = rbind(resultI[1:3,-1], AA[1,], resultI[4,-1], AA[2,], resultI[5:9,-1])
NresultI
resultI
resultI
X = c(0, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9, 1, 2)
NresultI = cbind(X, NresultI)
NresultI
dataI = as.data.frame(resultI)
dataI
dataI = as.data.frame(NresultI)
dataI
dataI$X
power_curve(data = dataI)
